#include "generate_hg.h"

#include <boost/program_options.hpp>
#include <boost/shared_ptr.hpp>

#include "context.h"
#include "input.h"
#include "silent.h"

#include "translator.h"
#include "phrasebased_translator.h"
#include "tagger.h"
#include "lextrans.h"
#include "lexalign.h"
#include "csplit.h"

#include "stringlib.h"
#include "hg.h"

using namespace std;
using boost::scoped_ptr;
using boost::shared_ptr;
namespace po = boost::program_options;

namespace pipeline {

void FirstPassTranslate::Register(OptDesc *opts) {
  opts->add_options()
      ("formalism,f", po::value<string>(), "Decoding formalism; values include SCFG, FST, PB, LexTrans (lexical translation model, also disc training), CSplit (compound splitting), Tagger (sequence labeling), LexAlign (alignment only, or EM training)")
      ("grammar,g", po::value<vector<string> >()->composing(), "Either SCFG grammar file(s) or phrase tables file(s)")
      ("per_sentence_grammar_file", po::value<string>(), "Optional (and possibly not implemented) per sentence grammar file enables all per sentence grammars to be stored in a single large file and accessed by offset")
      ("add_pass_through_rules,P", "Add rules to translate OOV words as themselves")
      ("goal", po::value<string>()->default_value("S"), "Goal symbol (SCFG & FST)")
      ("scfg_extra_glue_grammar", po::value<string>(), "Extra glue grammar file (Glue grammars apply when i=0 but have no other span restrictions)")
      ("scfg_no_hiero_glue_grammar,n", "No Hiero glue grammar (nb. by default the SCFG decoder adds Hiero glue rules)")
      ("scfg_default_nt,d", po::value<string>()->default_value("X"), "Default non-terminal symbol in SCFG")
      ("scfg_max_span_limit,S", po::value<int>()->default_value(10), "Maximum non-terminal span limit (except \"glue\" grammar)")
      ("coarse_to_fine_beam_prune", po::value<double>(), "Prune paths from coarse parse forest before fine parse, keeping paths within exp(alpha>=0)")
      ("ctf_beam_widen", po::value<double>()->default_value(2.0), "Expand coarse pass beam by this factor if no fine parse is found")
      ("ctf_num_widenings", po::value<int>()->default_value(2), "Widen coarse beam this many times before backing off to full parse")
      ("ctf_no_exhaustive", "Do not fall back to exhaustive parse if coarse-to-fine parsing fails")
      ("lextrans_dynasearch", "'DynaSearch' neighborhood instead of usual partition, as defined by Smith & Eisner (2005)")
      ("lextrans_use_null", "Support source-side null words in lexical translation")
      ("lextrans_align_only", "Only used in alignment mode. Limit target words generated by reference")
      ("tagger_tagset,t", po::value<string>(), "(Tagger) file containing tag set")
      ("csplit_output_plf", "(Compound splitter) Output lattice in PLF format")
      ("csplit_preserve_full_word", "(Compound splitter) Always include the unsegmented form in the output lattice")
      ("pb_max_distortion,D", po::value<int>()->default_value(4), "Phrase-based decoder: maximum distortion")
      ("show_tree_structure", "Show the Viterbi derivation structure") // !!!!
      ("weights,w", po::value<std::string>(), "Feature weights file (initial forest / pass 1)") // multiple occurrence
      ;
}

struct FirstPassTranslateImpl {
  typedef FirstPassTranslate::itype itype;
  typedef FirstPassTranslate::otype otype;
  FirstPassTranslateImpl(const VarMap &conf, Context *context) {
    // set up init weights
    context->init_weights_ptr = context->weights.Get(conf["weights"].as<string>());
    // set up translation back end
    string formalism = LowercaseString(conf["formalism"].as<string>());
    if (formalism == "scfg")
      translator_.reset(new SCFGTranslator(conf));
    else if (formalism == "fst")
      translator_.reset(new FSTTranslator(conf));
    else if (formalism == "pb")
      translator_.reset(new PhraseBasedTranslator(conf));
    else if (formalism == "csplit")
      translator_.reset(new CompoundSplit(conf));
    else if (formalism == "lextrans")
      translator_.reset(new LexicalTrans(conf));
    else if (formalism == "lexalign")
      translator_.reset(new LexicalAlign(conf));
    else if (formalism == "rescore")
      translator_.reset(new RescoreTranslator(conf));
    else if (formalism == "tagger")
      translator_.reset(new Tagger(conf));
    else
      throw invalid_argument("Unknown formalism: " + formalism);
    // TODO: Clean up this part
    bool csplit_preserve_full_word = conf.count("csplit_preserve_full_word");
    if (csplit_preserve_full_word &&
        (formalism != "csplit" || !(conf.count("beam_prune")||conf.count("density_prune")))) {
      cerr << "--csplit_preserve_full_word should only be "
           << "used with csplit AND --*_prune!\n";
      exit(1);
    }
    bool csplit_output_plf = conf.count("csplit_output_plf");
    if (csplit_output_plf && formalism != "csplit") {
      cerr << "--csplit_output_plf should only be used with csplit!\n";
      exit(1);
    }
  }
  ~FirstPassTranslateImpl() {}
  otype Apply(const Input &input, Context *context, itype /*arg*/) const {
    context->last_weights_ptr = context->init_weights_ptr;
    Hypergraph *forest = new Hypergraph;
    translator_->ProcessMarkupHints(input.sgml);
    bool translation_successful =
        translator_->Translate(input.to_translate,
                               context->smeta_ptr.get(),
                               *context->init_weights_ptr,
                               forest);
    translator_->SentenceComplete();
    if (!translation_successful) {
      if (!SILENT) { cerr << "  NO PARSE FOUND.\n"; }
      return Nothing<Hypergraph *>();
    }
    return Just(forest);
  }
 private:
  scoped_ptr<Translator> translator_;
};

FirstPassTranslate::FirstPassTranslate(const VarMap &conf, Context *context) : pimpl_(new FirstPassTranslateImpl(conf, context)) {}
FirstPassTranslate::~FirstPassTranslate() {}
FirstPassTranslate::otype FirstPassTranslate::Apply(const Input &input, Context *context, itype arg) const {
  return pimpl_->Apply(input, context, arg);
}

} // namespace pipeline
